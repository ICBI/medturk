#!/usr/bin/env python
'''
    medTurk (inspired by Amazon's Mechanical Turk) supports clinical research by using the 
    ingenuity of humans to convert unstructured clinical notes into structured data.

    Copyright (C) 2014 Innovation Center for Biomedical Informatics (ICBI)
                       Georgetown University <http://icbi.georgetown.edu/>
    
    Author: Robert M. Johnson "matt"
            <rmj49@georgetown.edu>
            <http://mattshomepage.com/>
            <@mattshomepage>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

from medturk.db import user as user_db
from flask import request, abort
from flask.ext.login import (UserMixin, login_user, logout_user, login_required, current_user)
from medturk.api import app, login_manager, mimerender, render_xml, render_json, render_html, render_txt
from itsdangerous import URLSafeTimedSerializer

'''
    @login_required decorators check to see if current_user.is_authenticated():
'''

login_serializer = URLSafeTimedSerializer(app.secret_key)

# The class that models a user
class User(UserMixin):
    def __init__(self, _id, _password, _authenticated):
        self.id            = _id
        self.password      = _password
        self.authenticated = _authenticated

    def is_active(self):
        return True

    def is_anonymous(self):
        return False

    def is_authenticated(self):
        return self.authenticated

    def get_id(self):
        return self.id


    def get_auth_token(self):
        data = [str(self.id), self.password]
        return login_serializer.dumps(data)



class UserManager():
    '''
        Manages users from database. Converts users on-the-fly to a 'User' object as required
        by Flask-Login
    '''
    def __init__(self):
        pass

    def meets_credentials(self, _id, _password):
        u = user_db.get_user(_id)
        return (u and user_db.hash_pass(_password, app.secret_key) == u['password'])


    def set_password(self, _id, _password):

        password_changed = False

        # Get the user from the database
        u = user_db.get_user(_id)

        # We can only authenticate this user, if he/she exists
        if u != None:
            password_changed = True

            # Save back to database
            user_db.update_user_password(u['_id'], _password, app.secret_key)

        return password_changed


    def set_authenticated(self, _id, is_authenticated):

            is_authenticated = False

            # Get the user from the database
            u = user_db.get_user(_id)

            # We can only authenticate this user, if he/she exists
            if u != None:
                is_authenticated = True
                user_db.update_user_authenticated(_id, is_authenticated)

            return is_authenticated

    def get_settings(self, _id):

        #Get the user from the database
        u = user_db.get_user(_id)
        
        if u != None:
            return {'name' : u['name']}

    def get(self, _id):

        # Get the user from the database
        u = user_db.get_user(_id)

        # We can only create and return a User object if he/she exists
        if u != None:
            return User(u['id'], u['password'], u['authenticated'])

        # Flask-Login specifies to return None if User does not exist
        return None

user_manager = UserManager()


@login_manager.user_loader
def load_user(_id):
    #For every Flask request, we reconstruct the User object
    return user_manager.get(_id)


@login_manager.token_loader
def load_token(token):
    """
    Flask-Login token_loader callback. 
    The token_loader function asks this function to take the token that was 
    stored on the users computer process it to check if its valid and then 
    return a User Object if its valid or None if its not valid.
    """

    #The Token itself was generated by User.get_auth_token.  So it is up to 
    #us to known the format of the token data itself.  

    #The Token was encrypted using itsdangerous.URLSafeTimedSerializer which 
    #allows us to have a max_age on the token itself.  When the cookie is stored
    #on the users computer it also has a exipry date, but could be changed by
    #the user, so this feature allows us to enforce the exipry date of the token
    #server side and not rely on the users cookie to exipre. 
    max_age = app.config["REMEMBER_COOKIE_DURATION"].total_seconds()

    #Decrypt the Security Token, data = [username, hashpass]
    data = login_serializer.loads(token, max_age=max_age)

    #Find the User
    u = user_manager.get(data[0])

    #Check Password and return user or None
    if u and data[1] == u.password:
        return u
    return None










@app.route("/user/login", methods=["POST"])
@mimerender(
            default = 'json',
            html = render_html,
            xml  = render_xml,
            json = render_json,
            txt  = render_txt
            )
def user_login():

    _id       = request.form.get('id')
    _password = request.form.get('password')
    
    if _id == None or len(_id) == 0:
        abort(415, 'User Id is missing')

    if _password == None or len(_password) == 0:
        abort(415, 'Password is missing')
  
    u = user_manager.get(_id)

    if user_manager.meets_credentials(_id, _password):

        # By setting "remember = True", 
        # this lets Flask-Login save a cookie to the user's computer
        login_user(u, remember=True)

        if user_manager.set_authenticated(current_user.get_id(), True):
            return {'success' : True, 'user' : clean_user(user_db.get_user(current_user.get_id()))}

    return {'success' : False} 





@app.route("/user/password/self/update", methods=["POST"])
@mimerender(
            default = 'json',
            html = render_html,
            xml  = render_xml,
            json = render_json,
            txt  = render_txt
            )
@login_required
def user_password_self_update_post():

    _current_password = request.form.get('current_password')
    _new_password = request.form.get('new_password')


    _id = current_user.get_id()
    if user_manager.meets_credentials(_id, _current_password):
        if user_manager.set_password(_id, _new_password):
            return {'success' : True}



    return {'success' : False}





@app.route("/user/logout")
@mimerender(
            default = 'json',
            html = render_html,
            xml  = render_xml,
            json = render_json,
            txt  = render_txt
            )
@login_required
def user_logout():
    user_manager.set_authenticated(current_user.get_id(), False)
    logout_user()
    return {'success' : True}




@app.route("/user")
@mimerender(
            default = 'json',
            html = render_html,
            xml  = render_xml,
            json = render_json,
            txt  = render_txt
            )
@login_required
def user():
    return {'user' : user_db.get_user(current_user.get_id())}

def clean_user(user):
    return {'id' : user['id'], '_id' : user['_id'], 'is_admin' : user['is_admin']}


@app.route("/users")
@mimerender(
            default = 'json',
            html = render_html,
            xml  = render_xml,
            json = render_json,
            txt  = render_txt
            )
@login_required
def users():
    users = [clean_user(u) for u in user_db.get_users()]
    return {'users' : users}



# TODO: Only available to admin
@app.route('/user/create', methods=['POST'])
@mimerender(
            default = 'json',
            html = render_html,
            xml  = render_xml,
            json = render_json,
            txt  = render_txt
            )
@login_required
def user_create():

    email     = request.form.get('id')
    password  = request.form.get('password')
    is_admin  = request.form.get('is_admin')
    is_admin = is_admin.lower() == 'true'
    user = user_db.create_user(email, password, is_admin, app.secret_key)
    return {'user' : user}


# TODO: Only available to admin
@app.route('/user/delete', methods=['POST'])
@mimerender(
            default = 'json',
            html = render_html,
            xml  = render_xml,
            json = render_json,
            txt  = render_txt
            )
@login_required
def user_delete_post():

    _id  = request.form.get('_id')
    user_db.delete_user(_id)
  
    return {'msg' : 'success'}



# TODO: Only available to admin
@app.route('/user/email', methods=['POST'])
@mimerender(
            default = 'json',
            html = render_html,
            xml  = render_xml,
            json = render_json,
            txt  = render_txt
            )
@login_required
def user_email_post():

    _id       = request.form.get('_id')
    _email     = request.form.get('email')
    user_db.update_user_email(_id, _email)
    return {'status' : 'success'}


# TODO: Only available to admin
@app.route('/user/is_admin/update', methods=['POST'])
@mimerender(
            default = 'json',
            html = render_html,
            xml  = render_xml,
            json = render_json,
            txt  = render_txt
            )
@login_required
def user_is_admin_update_post():

    _user_id  = request.form.get('user_id')
    _is_admin = request.form.get('is_admin')
    _is_admin = _is_admin.lower() == 'true'
    user_db.update_user_is_admin(_user_id, _is_admin)
    return {'status' : 'success'}


# TODO: Only available to admin
@app.route('/user/password', methods=['POST'])
@mimerender(
            default = 'json',
            html = render_html,
            xml  = render_xml,
            json = render_json,
            txt  = render_txt
            )
@login_required
def user_password_post():

    _id        = request.form.get('_id')
    _password  = request.form.get('password')
    user_db.update_user_password(_id, _password, app.secret_key)
    return {'status' : 'success'}
